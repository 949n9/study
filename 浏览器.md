##首先了解浏览器的线程模型是怎样的？

程序：计算机可以执行的代码，存在**磁盘**中 --- 这是静止的（比如这是买的一块地皮）；

进程：把 **程序** 调入到内存中，等待被**CPU**执行 --- 这是活动的（这是在地皮上建起来的几个工厂）；

线程：是CPU执行 **进程** 代码的基本单位 --- 相当于生产任务(这是在工厂中进行生产的生产线)；

而 进程 与 线程 的关系是：进程是操作系统分配内存的基本单位，线程处于进程内部，是CPU执行代码的基本单位，一个进程中至少有一个线程，也可以有多个（就比如在一个工程内，可以有一条生产线，也可以有多条生产线），多个线程间并发执行，从宏观上看是‘同时’执行，微观上看是‘轮流’执行。



拿chrome中的线程模型举例

1.chrome 中发起HTTP请求最多可以使用6个并发线程；

2.而负责向页面中执行绘制任务(HTML/CSS/JS/事件处理代码)的只有1个线程 --- UI主线程，如果碰到耗时的代码就有问题了，解决的办法：创建一个新的线程，去执行耗时的JS任务 -- 与UI主线程并发执行



Worker 线程的缺点：浏览器禁止Worker线程操作任何BOM 和 DOM对象，不能使用Worder加载类似jQuery.js文件。



## 浏览器如何解析css选择器？

浏览器会『从右往左』解析CSS选择器。

我们知道DOM Tree与Style Rules合成为 Render Tree，实际上是需要将*Style Rules*附着到DOM Tree上，因此需要根据选择器提供的信息对DOM Tree进行遍历，才能将样式附着到对应的DOM元素上。

以下这段css为例

```css
.mod-nav h3 span {font-size: 16px;}
```

我们对应的DOM Tree 如下:

![屏幕快照 2019-10-07 下午11.10.30](https://tva1.sinaimg.cn/large/006y8mN6ly1g7q1h8vtvmj30pc0j4qai.jpg)

若从左向右的匹配，过程是：

1. 从 .mod-nav 开始，遍历子节点 header 和子节点 div
2. 然后各自向子节点遍历。在右侧 div 的分支中
3. 最后遍历到叶子节点 a ，发现不符合规则，需要回溯到 ul 节点，再遍历下一个 li-a，一颗DOM树的节点动不动上千，这种效率很低。

如果从右至左的匹配：

1. 先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3
2. 由 h3再向上寻找 class=mod-nav 的节点
3. 最后找到根元素 html 则结束这个分支的遍历。

后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。


## JSONP原理以及实现

利用了标签的src属性不受跨域限制，但是也仅限get请求

手写一个JSONP跨域：

```js
function JSONP({  
  url,
  params,
  callbackKey,
  callback
}) {
  // 在参数里制定 callback 的名字
  params = params || {}
  params[callbackKey] = 'jsonpCallback'
    // 预留 callback
  window.jsonpCallback = callback
    // 拼接参数字符串
  const paramKeys = Object.keys(params)
  const paramString = paramKeys
    .map(key => `${key}=${params[key]}`)
    .join('&')
    // 插入 DOM 元素
  const script = document.createElement('script')
  script.setAttribute('src', `${url}?${paramString}`)
  document.body.appendChild(script)
}

JSONP({  
  url: 'http://s.weibo.com/ajax/jsonp/suggestion',
  params: {
    key: 'test',
  },
  callbackKey: '_cb',
  callback(result) {
    console.log(result.data)
  }
})

```





CORS

Cross Origin Resource Share

