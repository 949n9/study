

## 网络模型

应用层 

传输层

## 三次握手

### 前置知识

*序号*：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

*SYN*：Synchronize Sequence Numbers，即同步序列编号，发起一个新连接,是TCP/IP建立连接时使用的握手信号。

*ACK*：Acknowledge character，即是确认字符，在数据通信中，接收站发给发送站的一种传输类[控制字符](https://baike.baidu.com/item/控制字符/6913704)。表示发来的数据已确认接收无误。

*RST*：重置连接。

*FIN*：Function Item Number，TCP报头的码位字段，该位置为1的含义为发送方[字节流](https://baike.baidu.com/item/字节流)结束，用于关闭连接







所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。

![屏幕快照 2019-10-02 下午10.48.34](https://tva1.sinaimg.cn/large/006y8mN6ly1g7k8r5u0p8j310u0q0q72.jpg)






##  四次挥手

**（1）第一次挥手**

客户端主动关闭方发送一个FIN，用来关闭客户端到服务器端的数据传送，也就是客户端告诉服务器端：我已经不会再给你发数据了， (当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，客户端依然会重发这些数据)，**但是，此时客户端还可以接受数据**。

**（2）第二次挥手**

服务端收到FIN包后，发送一个ACK给客户端，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。

**（3）第三次挥手**

服务器端发送一个FIN，用来关闭服务器端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发送数据了！！！

**（4）第四次挥手**

客户端收到 FIN 后，发送一个 ACK 给服务端，确认序号为收到序号 + 1，至此，完成四次挥手。





为什么进行4次挥手？

TCP 是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。

具体详解：

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出`FIN`报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

## 状态码


| 状态码 | 含义                                           |
| :----- | ---------------------------------------------- |
| 1xx    | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2xx    | 成功，操作被成功接收并处理                     |
| 3xx    | 重定向，需要进一步的操作以完成请求             |
| 4xx    | 客户端错误，请求包含语法错误或无法完成请求     |
| 5xx    | 服务器错误，服务器在处理请求的过程中发生了错误 |
比较重要的几个



| 状态码 | 含义 |
| :------ | :----------------------------------------------------------- |
| 101    | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议（websoket） |
| 200    | 请求成功。一般用于GET与POST请求                              |
| 204    | 无内容（无响应体）。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 206 | 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 |
| 301 | 永久重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302 | 临时重定向。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 304 | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 401 | 请求要求用户的身份认证 |
| 403 | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 | 服务器无法根据客户端的请求找到资源（网页） |
| 405 | 客户端试图使用一个本资源不支持的HTTP方法。例如：一个资源只支持GET方法，但是客户端使用PUT方法访问。 |
| 500 | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 |
| 502 | 只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。 |




## 常见面试题

### 从输入一个url后，到页面显示，发生了什么？

- DNS解析
- 发起TCP连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束



#### DNS解析

DNS解析实际上就是寻找你所需要的资源的过程。假设你输入`www.baidu.com`，而这个网址并不是百度的真实地址，互联网中每一台机器都有唯一标识的IP地址，这个才是关键，但是它不好记，乱七八糟一串数字谁记得住啊，所以就需要一个网址和IP地址的转换，也就是DNS解析。

#### DNS负载均衡

不知道你们有没有注意这样一件事，你访问`baidu.com`的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，假设只有一个服务器，那它的性能和存储量要多大才能支撑这样大量的访问呢？DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡。

https://juejin.im/post/5cc573c85188252e741ccbb6



用户输入url，到浏览器缓存机制检查，到HTTP请求包结构，到DNS解析，到连接建立，到服务器端处理（如动态页面处理、静态页面返回，CDN相关知识），到浏览器收到HTML内容怎么解析，到怎么并行加载串行执行CSS、JS，到怎么构造渲染树渲染页面，到怎么根据请求头把内容缓存到浏览器端。如果此时你还能补充HTTPS、同构直出、Service Worker之类，那就更好。





## https和http有什么区别？



## TCP 握手，分手，拥塞控制，流量控制


管线化







request header 

Accept header





Response header



压缩

缓存

​	强制缓存

​	对比缓存

 		GTM时间对比

​		 摘要对比（比较精准）



摘要`Etag`



<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g73zlo6nndj30t81864fb.jpg" alt="image-20190918212322709" style="zoom:50%;" />



### 解析URL成为对象

```
var url = "https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=nodemon&rsv_sug4=2634";

function parseQueryString(url){
    var urlKey = url.split("?")[1]
    var objKeyValue ={}
    if(urlKey){
        var urlObj = urlKey.split("&")
        // 以对象形式存放
        for(var i = 0; i<urlObj.length;i++){
            objKeyValue[urlObj[i].split("=")[0]] = urlObj[i].split("=")[1]
        }
        return objKeyValue
    }else{
        return "暂无参数"
    }
}

var s = parseQueryString(url)
console.log(s)
```